/* Вам необхідно реалізувати функцію memoize(fn), яка приймає вхід функцію і додає їй можливість 
кешування результатів виконання, щоб уникнути повторних обчислень. Це означає, що в разі,
 коли функція викликається з однаковими параметрами, то результат необхідно брати з кешу. 
 (Тільки примітиви у параметрах та використовуйте Map) */

/*  Встановіть обмеження на розмір кеша у вигляді числа N. Якщо це значення перевищено,
  то вам необхідно перезаписати перше значення, потім друге і так далі.
Додайте перевірку, щоб прибрати дублікати результатів із кешу. */

function memoize(fn, maxCacheSize = 5) {
    const cache = new Map(); // Використовуємо Map для кешування
  
    return function(...args) {
      const key = args.map(arg => (arg === Object(arg) ? arg : String(arg))).join(","); // Створюємо ключ з параметрів
  
      // Якщо результат вже є в кеші, повертаємо його
      if (cache.has(key)) {
        return cache.get(key);
      }
  
      // Якщо результату немає в кеші, обчислюємо його
      const result = fn(...args);
  
      // Якщо результат вже є в кеші (перевірка на дублікати), повертаємо його без кешування
      if (Array.from(cache.values()).includes(result)) {
        return result;
      }
  
      // Додаємо результат в кеш
      cache.set(key, result);
  
      // Якщо розмір кешу перевищує maxCacheSize, видаляємо перші значення
      if (cache.size > maxCacheSize) {
        const firstKey = cache.keys().next().value;
        cache.delete(firstKey);
      }
  
      return result;
    };
  }